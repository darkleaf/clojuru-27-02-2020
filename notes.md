# 1
Привет.
Меня зовут Михаил и я расскажу вам о библиотеке effect.
Ссылку на github вы видите на экране.

# 2
Я расскажу про тестирование кода с побочными эффектами.
В том числе про тестирование ассинхронного кода синхронно.
И немного про сохранение и восстановление вычисления,
даже на другой машине и даже платформе.
Наверное, вы уже начали догадываться, что обработка эффектов построена на корутинах.

Начнем с тестов.

# 3
У нас есть обычная функция с 2мя побочными эффектами:
получение случайного идентификатора и текущей даты.

Как протестировать эту функцию?
Как понять, что она получает именно текущую дату?

#4
Например, можно использовать чистую функцию и
передавать ей заранее вычисленные значения.
Такие функции очень просто тестировать.
Но их не удобно использовать.

#5
Бывают ситуации, когда значение используется не всегда,
а вычислять его нужно каждый раз.

# 6
Можно использовать подход принятый в Java или C# -
внедрение зависимостей, например через конструктор.

В данном случае есть фабрика, принимающая зависимости,
которая производит нужную функцию.

Да, тут уже не нужно вычислять значения заранее.

Но есть сложности с тестированим

# 7
Чтобы протестировать порядок вызовов зависимостей в такой фукнции
нужно использовать изменяемое состояние.
Так себе идея.

# 8
Немного лучше выглядит использование динамических переменных.
Но все сложности с тестированим остаются.

# 9
Но что если не принимать зависимости через аргументы, явно или неявно через контекст,
а возвращать  эффект и продолжение функции?
Ведь у нас есть замыкания, и остаток функции будет иметь доступ ко всем ранее объявленным значениям.

При этом происходит четкое разделение на логику и интерпретацию эффектов.

Если присмотреться и подумать, то эффекты можно вычислять и ассинхронно. Но об этом поговорим позже.

С таким подходом можно сделать рекурсию и даже с оптимизацией хвостовой рекурсии.
Но не любой код можно предстваить в такой форме.

Так мы подходим к библиотеке эффектов.

# 10
Вы можете найти ее исходники на гитхабе.

Основа API макрос `with-effects` и функции  `!`, `effect`,  а так же `continuation`.
Рассмотрим их подробнее.

# 11

Макрос компилирует код в SSA форму с помощью библиотеки cloroutine,
по аналоги с тем, как это делает `core.async`.
И получается без стековая корутина, которую можно использовать только один раз,
что не удобно.

# 12

Функция `continuation` добавляет поддержку стека и позволяет использовать корутину несколько раз,
т.е. делает ее иммутабельной.

# 13

`!` - показывает компилятору, где происходит разрыв функции.

Эта функция принимает эффект.
Эффектом может быть любое значение с поддержкой метаданых:
вектора, хэши, множества, символы и т.д.

Т.к. есть поддержка стека, то можно вызвать другою функцию с эффектами.

Если вдруг ваша функция стала чистой, то не нужно менять вызывающий код:
`!`  просто вернет свой агрумент.

И это именно функция, а не макрос: вы можете заранее подготавливать эффекты.

# 14

Эффекты - это хорошо, но сами по себе они бесполезны.
Нужен интерпретатор, который сделает всю грязную работу.

Нам нужн функция, которая преобразует эффект в коэффект взаимодейсвуя с внешним миром.
Например, генерируя случайное число или отпраляя данные по сети.

В данном случае генерации случайного числа не происходит, а просто возвращается
заранее заготовленное число - 0,75.

Вызвав нашу функцию с данной реализацией побочных эффектов, мы получаем ожидаемый результат вычисления - 0,5.

# 15

Т.к. наша функция детерминированная, ее поведение можно записать в виде сценария.
Мы указываем с какими агрументами она вызывается, какие эффекты и в каком порядке вызывает,
какие коэффеты получает, чтобы вернуть заданное значение.

Здесь на важно как будут обрабатываться эффекты - синхронно или ассинхронно.
И можно тестировать синхронно код, предназначенный для ассинхронного окружения, например для браузера.

На самом деле есть несколько управляющих конструкций,
например, можно описать какое исключение должно быть брошено.

# 16

Т.к. фукнция прерывается, но эффекты можно выполнять ассинхронно.

Для этого функция `effect-!>coeffect` дожна возващать значение через колбэк.


# 17

Да, в Clojure или JVM нет родной поддержки корутин.
И это добавляет цвет нашим функциям.
Например, мы не можем использовать фукнции с эффектами вместе с снандартными фукнциями высших порядков,
вроде map и reduce.

Но библиотека добавляет собственные функции и макросы для работы с эффектами.
Да, вы можете предавать обычные фукнции, т.к. `!` умеет работать со всем.

# 18

Чтобы делать разные разные интересные штуки есть поддержка middleware.
Вот middleware, которая ничего не делает.

# 19

Есть middleware - context.
Она позволят использовать общий контекст для всего вычисления.
Аналог монады State.

# 20

Есть middleware - reduced, на ее базе можно построить монады Maybe и Either.

Если обработчик вернет заначение, обернутое в reduced, то все вычисление вернет это значение.

# 21

Самое сложное - это middleware Log.

Она ведет журнал эффектов и коффектов и позволяет заморозить вычисление.
Если обработчик вернет keywork `suspend`, то вычисление вернет этот журнал.

Спустя какое-то время, можно накатить этот журнал на новую континуацию
и восстановить состояние.

Так можно переносить вычисление между машинами или платформами,
с бэкенда на фронтенд и обратно.

# 22

С помощью моей библиотеки можно строить приложение на архитектуре
functional core & imperative shell,
т.е. все решения принимать в ядре, а в оболочку вынести прямолинейный код для взаимодействия с внешним миром.

Можно писать код в cljc, тестировать его синхронно на JVM, а запускать в браузере.
